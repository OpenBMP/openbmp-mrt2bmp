import json
import multiprocessing
import os
import time
import struct
import socket
import datetime
from struct import *
from mrtparse import Reader
from openbmp.mrt2bmp.HelperClasses import Q_Message

from openbmp.mrt2bmp.logger import init_mp_logger

mrt_types = {
    11: 'OSPFv2',
    12: 'TABLE_DUMP',
    13: 'TABLE_DUMP_V2',
    16: 'BGP4MP',
    17: 'BGP4MP_ET',
    32: 'ISIS',
    33: 'ISIS_ET',
    48: 'OSPFv3',
    49: 'OSPFv3_ET'
}

table_dump_v2_subtypes = {
    1: 'PEER_INDEX_TABLE',
    2: 'RIB_IPV4_UNICAST',
    3: 'RIB_IPV4_MULTICAST',
    4: 'RIB_IPV6_UNICAST',
    5: 'RIB_IPV6_MULTICAST',
    6: 'RIB_GENERIC',
}

class BGP_Helper:

    def createBgpHeader(self, data_length, message_type):

        """
        BGP Message Header Format:

          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |                                                               |
          +                                                               +
          |                                                               |
          +                                                               +
          |                           Marker                              |
          +                                                               +
          |                                                               |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |          Length               |      Type     |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

          1 - OPEN
          2 - UPDATE
          3 - NOTIFICATION
          4 - KEEPALIVE

        """

        # Marker
        marker = '\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF'

        # Length
        length = struct.pack("!H", data_length + 19)

        # Type
        type = struct.pack("!B", message_type)

        return marker + length + type

    def createBgpOpenMessage(self, as_number, hold_time, bgp_iden, remote_asn):

        """
        Open Message Format:

           0                   1                   2                   3
           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
           +-+-+-+-+-+-+-+-+
           |    Version    |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |     My Autonomous System      |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |           Hold Time           |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                         BGP Identifier                        |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           | Opt Parm Len  |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                                                               |
           |             Optional Parameters (variable)                    |
           |                                                               |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

        The current BGP version number is 4.

        """

        # Version
        version = struct.pack("!B", 4)

        # My Autonomous System
        my_autonomous_system = struct.pack("!H", as_number)

        # Hold Time
        hold_time = struct.pack("!H", hold_time)

        # BGP Identifier
        bgp_identifier = socket.inet_pton(socket.AF_INET, bgp_iden)

        # Optional Parameters (Add BGP Capabilities)
        octet_4_as_cap = struct.pack("!B B", 2, 6) + struct.pack("!B B I", 65, 4, remote_asn)

        # Add AFI, SAFI values to caps.
        mp_ipv4_unicast_cap = struct.pack("!B B", 2, 6) + struct.pack("!B B H B", 1, 4, 1, 1)
        mp_ipv6_unicast_cap = struct.pack("!B B", 2, 6) + struct.pack("!B B H B", 1, 4, 2, 1)

        #optional_parameters = octet_4_as_cap + mp_ipv4_unicast_cap + mp_ipv6_unicast_cap
        optional_parameters = octet_4_as_cap + mp_ipv4_unicast_cap + mp_ipv6_unicast_cap

        # Optional Parameters Length
        optional_parameters_length = struct.pack("!B", len(optional_parameters))

        # Open Message
        open_message = version + my_autonomous_system + hold_time + bgp_identifier + optional_parameters_length \
            + optional_parameters

        # Bgp Header
        bgp_header = self.createBgpHeader(len(open_message), 1)

        return bgp_header + open_message

    def createBgpUpdateMessage(self):

        """




        """

        pass


class BMP_Helper:

    def createBmpCommonHeader(self, version, data_length, msg_type):

        """
        BMP Common Header:

          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
         +-+-+-+-+-+-+-+-+
         |    Version    |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                        Message Length                         |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |   Msg. Type   |
         +---------------+

        Message Types:
          *  Type = 0: Route Monitoring
          *  Type = 1: Statistics Report
          *  Type = 2: Peer Down Notification
          *  Type = 3: Peer Up Notification
          *  Type = 4: Initiation Message
          *  Type = 5: Termination Message
          *  Type = 6: Route Mirroring Message

        """

        return struct.pack("!B I B", version, data_length, msg_type)


    def createBmpPerPeerHeader(self, p_type, p_dist, peer, ts_s, ts_ms):

        """
        BMP Peer Header:

          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |   Peer Type   |  Peer Flags   |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |         Peer Distinguisher (present based on peer type)       |
         |                                                               |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                 Peer Address (16 bytes)                       |
         ~                                                               ~
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                           Peer AS                             |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                         Peer BGP ID                           |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                    Timestamp (seconds)                        |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                  Timestamp (microseconds)                     |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

          *  Peer Type = 0: Global Instance Peer
          *  Peer Type = 1: RD Instance Peer
          *  Peer Type = 2: Local Instance Peer

          Peer Flags:

         0 1 2 3 4 5 6 7
         +-+-+-+-+-+-+-+-+
         |V|L|A| Reserved|
         +-+-+-+-+-+-+-+-+
        """

        peer_flags = 0

        # V bit
        if peer['ip_address_family'] == "IPv4":
            # Zero added to peer_flags
            peer_address = struct.pack('!12x') + socket.inet_pton(socket.AF_INET, peer['ip_address'])

        elif peer['ip_address_family'] == "IPv6":
            peer_flags += 1
            peer_address = socket.inet_pton(socket.AF_INET6, peer['ip_address'])

        # L bit
        peer_flags += 2

        # A bit
        if peer['as_number_size'] == 4:
            # Zero
            pass

        elif peer['as_number_size'] == 2:
            peer_flags += 4

        bgp_id = socket.inet_pton(socket.AF_INET, peer['bgp_id'])

        return struct.pack("!B B Q", p_type, peer_flags, p_dist) + peer_address + struct.pack("!I", int(peer['asn'])) \
            + bgp_id + struct.pack("!I I", ts_s, ts_ms)

class RibProcessor(BMP_Helper, BGP_Helper):

    def __init__(self, file_path, directory_path, router_name, collector_id, forward_queue, log_queue):
        self._file_path = file_path
        self._directory_path = directory_path
        self._router_name = router_name
        self._collector_id = collector_id
        self._forward_queue = forward_queue
        self._log_queue = log_queue

        # Peer index table is array of dictionaries.
        self._peer_index_table = None
        self.__setPeerIndexTable()
        self.__savePeerIndexTable()

    # Main process function to be called.
    def processRibFile(self):
        self._readTableEntries()

    def _readTableEntries(self):
        # Read table dump entries.
        d = Reader(os.path.join(self._directory_path, self._router_name, self._file_path))

        for m in d:
            m = m.mrt

            # TABLE_DUMP_V2 - RIB_IPV4_UNICAST OR RIB_IPV6_UNICAST entry
            if 'TABLE_DUMP_V2' == mrt_types[m.type] and ('RIB_IPV4_UNICAST' == table_dump_v2_subtypes[m.subtype] or
                                                                 'RIB_IPV6_UNICAST' == table_dump_v2_subtypes[m.subtype]):

                """
                    RIB Entry Header:

                    0                   1                   2                   3
                    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |                         Sequence Number                       |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   | Prefix Length |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |                        Prefix (variable)                      |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |         Entry Count           |  RIB Entries (variable)
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                """

                # Parse RIB entry header.
                sequence_number = m.rib.seq
                prefix_length = m.rib.plen
                prefix = m.rib.prefix
                entry_count = m.rib.count

                """
                    RIB Entry:

                    0                   1                   2                   3
                    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |         Peer Index            |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |                         Originated Time                       |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |      Attribute Length         |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |                    BGP Attributes... (variable)
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                """

                for entry in m.rib.entry:
                    peer_index = entry.peer_index
                    originated_time = entry.org_time
                    attribute_length = entry.attr_len

                    print "Start of BGP attributes..."
                    for attr in entry.attr:
                        print 'Path Attribute Flags/Type/Length: 0x%02x/%d/%d' % (attr.flag, attr.type, attr.len)
                    print "End of BGP attributes..."


    # Peer Index Table functions.
    def __setPeerIndexTable(self):
        d = Reader(os.path.join(self._directory_path, self._router_name, self._file_path))

        for m in d:
            m = m.mrt

            if m.type == 13 and m.subtype == 1:
                # Create list of dicts.
                peerList = []

                for entry in m.peer.entry:
                    peer = dict()
                    peer['type'] = entry.type

                    # AS number size in bytes (2 bytes or 4 bytes)
                    if entry.type == 0:
                        peer['as_number_size'] = 2
                        peer['ip_address_family'] = 'IPv4'

                    elif entry.type == 1:
                        peer['as_number_size'] = 2
                        peer['ip_address_family'] = 'IPv6'

                    elif entry.type == 2:
                        peer['as_number_size'] = 4
                        peer['ip_address_family'] = 'IPv4'

                    elif entry.type == 3:
                        peer['as_number_size'] = 4
                        peer['ip_address_family'] = 'IPv6'

                    peer['bgp_id'] = entry.bgp_id
                    peer['ip_address'] = entry.ip
                    peer['asn'] = int(entry.asn)

                    peerList.append(peer)

                    self.__sendPeerUpMessage(peer)
                    time.sleep(15)

                self._peer_index_table = peerList

            break

    def __sendPeerUpMessage(self, peer):

        # peer up message = Common header + per-peer header + peer up notification
        peer_up_notification = self.__createPeerUpNotification(peer)

        per_peer_header = self.createBmpPerPeerHeader(0, 0, peer, 0, 0)

        common_header = self.createBmpCommonHeader(3, len(per_peer_header) + len(peer_up_notification) + 6, 3)

        qm = Q_Message(Q_Message.BMP_MESSAGE, common_header + per_peer_header + peer_up_notification)

        self._forward_queue.put(qm)

    def __createPeerUpNotification(self, peer):

        """
          Peer Up Notification:

          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                 Local Address (16 bytes)                      |
         ~                                                               ~
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |         Local Port            |        Remote Port            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                    Sent OPEN Message                          |
         ~                                                               ~
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                  Received OPEN Message                        |
         ~                                                               ~
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                 Information (variable)                        |
         ~                                                               ~
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

        """

        # Local Address
        local_address = None

        if peer['ip_address_family'] == 'IPv4':
            local_address = struct.pack('!12x') + socket.inet_pton(socket.AF_INET, "0.0.0.0")

        elif peer['ip_address_family'] == 'IPv6':
            local_address = socket.inet_pton(socket.AF_INET6, "0:0:0:0:0:0:0:0")

        # Local Port
        local_port = pack('!H', 0)

        # Remote Port
        remote_port = pack('!H', 0)

        # Sent OPEN Message
        sent_open_message = self.createBgpOpenMessage(0, 0, self._collector_id, peer['asn'])

        # Received OPEN Message
        received_open_message = self.createBgpOpenMessage(peer['asn'], 0, peer['bgp_id'], 0)

        return local_address + local_port + remote_port + sent_open_message + received_open_message


    def __savePeerIndexTable(self):

        # Save peer index table as json
        path = os.path.join(self._directory_path, self._router_name, 'router_pit.json')

        # Init json object to be saved in a file.
        jsonToSave = {}
        jsonToSave['router_name'] = self._router_name
        jsonToSave['collector_id'] = self._collector_id
        jsonToSave['peer_list'] = self._peer_index_table
        jsonToSave['peer_index_table_source'] = self._file_path

        with open(path, 'w') as fp:
            json.dump(jsonToSave, fp, sort_keys=True, indent=4)


class UpdateProcessor(BMP_Helper, BGP_Helper):

    def __init__(self, file_path, directory_path, router_name, collector_id, forward_queue, log_queue):
        self._isProcessable = True
        self._peer_index_table = None
        self._file_path = file_path
        self._directory_path = directory_path
        self._router_name = router_name
        self._collector_id = collector_id
        self._forward_queue = forward_queue
        self._log_queue = log_queue

        # Load peer index table from router_pit.json in router directory.
        self.__loadPeerIndexTable()

    def processUpdateFile(self):

        if self._isProcessable:
            pass

    def __loadPeerIndexTable(self):

        # If router_pit.json exists, then load peer index table.
        path = os.path.join(self._directory_path, self._router_name, 'router_pit.json')

        if os.path.isfile(path):
            with open(path) as data_file:
                self._peer_index_table = json.load(data_file)

        # Else, does not process the update file because there is no peer index table.
        else:
            self._isProcessable = False
            print "There is no peer index table for the update file: %s,%s" % self._router_name, self._file_path


class RouterProcessor(BMP_Helper):

    def __init__(self, router_name, directory_path, forward_queue, log_queue, cfg):

        self._cfg = cfg
        self._isToProcess = True
        self._router_name = router_name
        self._directory_path = directory_path
        self._fwd_queue = forward_queue
        self._log_queue = log_queue
        self._collector_id = None
        self._listOfRibAndUpdateFiles = []

        self.__collectListOfRibandUpdateFiles()
        self.__readCollectorId()
        self.__sendInitMessage()

        self.LOG = init_mp_logger("mrt_parser", self._log_queue)

    def __collectListOfRibandUpdateFiles(self):

        for d in os.listdir(os.path.join(self._directory_path, self._router_name)):
            if not d.startswith('.') and d != "router_pit.json":
                listOfRibs = os.listdir(os.path.join(self._directory_path, self._router_name, d, "RIBS"))
                listOfRibs = [os.path.join(d,"RIBS",e) for e in listOfRibs]
                listOfUpdates = os.listdir(os.path.join(self._directory_path, self._router_name, d, "UPDATES"))
                listOfUpdates = [os.path.join(d,"UPDATES",e) for e in listOfUpdates]
                self._listOfRibAndUpdateFiles = self._listOfRibAndUpdateFiles + listOfRibs + listOfUpdates

        # Create tuple list from list of ribs and updates.
        sorting_list = []

        for i, f in enumerate(self._listOfRibAndUpdateFiles):
            if ".bz2" in f:
                # Parse date of the file.
                tokens = f.split('.')
                date = tokens[2] + tokens[3]
                date = datetime.datetime(int(date[0:4]), int(date[4:6]), int(date[6:8]), int(date[8:10]), int(date[10:]))
                sorting_list.append((date, f))

        # Sorts files by their timestamp.
        def getDate(fileInfo):
            return fileInfo[0]

        sorting_list.sort(key=getDate)

        # If there is no file to process, then exit and do not run process function.
        if len(sorting_list) == 0:
            self._isToProcess = False
            return

        else:
            prevFileTimestamp = sorting_list[0][0]

            # Checks if there is an abnormality between mrt file timestamps.
            for f in sorting_list:
                currentFileTimestamp = f[0]
                timeDif = currentFileTimestamp - prevFileTimestamp

                if timeDif.total_seconds()/60 <= self._cfg['timestamp_interval_limit']:
                    pass

                else:
                    # There is an abnormality between timestamps of two files.
                    self._isToProcess = self._cfg['ignore_timestamp_interval_abnormality']
                    print "There is an abnormality between timestamps of two files in %s ." % self._router_name

                prevFileTimestamp = currentFileTimestamp

        self._listOfRibAndUpdateFiles = sorting_list


    def __readCollectorId(self):

        if self._isToProcess:

            # If router_pit.json exists, then read collector id from that file.
            path = os.path.join(self._directory_path, self._router_name, 'router_pit.json')

            if os.path.isfile(path):
                with open(path) as data_file:
                    data = json.load(data_file)
                    self._collector_id = data['collector_id']

            else:
                # If not, then read collector_id from the first rib file.
                firstRIB = self._listOfRibAndUpdateFiles[0][1]
                d = Reader(os.path.join(self._directory_path, self._router_name, firstRIB))
                for m in d:
                    m = m.mrt

                    if m.type == 13 and m.subtype == 1:
                        self._collector_id = m.peer.collector
                        break

    def __sendInitMessage(self):

        # Generate information TLVs about monitored router.
        """
         TLV Structure:

          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |          Information Type     |       Information Length      |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                 Information (variable)                        |
         ~                                                               ~
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

         Type = 0: String
         Type = 1: sysDescr
         Type = 2: sysName

         sysDescr and sysName are must to sent.
        """

        # sysDescr tlv creation
        f1 = '!H H 1s'
        s1 = calcsize(f1)
        sysDescr_data = pack(f1, 1, 1, ' ')

        # sysName tlv creation
        f2 = '!H H ' + str(len(self._router_name)) + 's'
        s2 = calcsize(f2)
        sysName_data = pack(f2, 2, len(self._router_name), self._router_name)

        common_header = self.createBmpCommonHeader(3, s1 + s2 + 6, 4)

        qm = Q_Message(Q_Message.BMP_MESSAGE, common_header + sysDescr_data + sysName_data)

        self._fwd_queue.put(qm)

    def processRouteView(self):
        if self._isToProcess:
            for f in self._listOfRibAndUpdateFiles:
                if "rib" in f[1]:
                    pass
                    rp = RibProcessor(f[1], self._directory_path, self._router_name, self._collector_id, self._fwd_queue, self._log_queue)
                    #rp.processRibFile()

                elif "updates" in f[1]:
                    pass
                    #up = UpdateProcessor(f[1], self._directory_path, self._router_name, self._collector_id, self._fwd_queue, self._log_queue)
                    #up.processUpdateFile()

        else:
            self.LOG.error("Data of %s cannot be processed...") % self._router_name

class RouteViewsProcessor(multiprocessing.Process):

    def __init__(self, cfg, forward_queue, log_queue):
        """ Constructor

            :param cfg:             Configuration dictionary
            :param forward_queue:   Output for BMP raw message forwarding
            :param log_queue:       Logging queue - sync logging
        """

        multiprocessing.Process.__init__(self)
        self._stop = multiprocessing.Event()

        self._cfg = cfg
        self._fwd_queue = forward_queue
        self._log_queue = log_queue
        self._dir_path = cfg['save_directory_path']
        self.LOG = None

    def run(self):
        """ Override """
        self.LOG = init_mp_logger("mrt_parser", self._log_queue)

        self.LOG.info("Running route_views_processor")

        # Get list of router list from the directory.
        listOfRouters = os.listdir(self._dir_path)

        try:
            # Iterate all routers.
            for router in listOfRouters:

                if router.startswith('route-views.') and not self.stopped():

                    # Process the router by creating a 'RouterProcessor'
                    rp = RouterProcessor(str(router), self._dir_path, self._fwd_queue, self._log_queue, self._cfg)
                    rp.processRouteView()

                    # Create reconnect message and enqueue the message.
                    qm = Q_Message(Q_Message.RECONNECT_MESSAGE)
                    #self._fwd_queue.put(qm)

        except KeyboardInterrupt:
            pass

        self.LOG.info("route_views_processor stopped")

    def stop(self):
        self._stop.set()

    def stopped(self):
        return self._stop.is_set()