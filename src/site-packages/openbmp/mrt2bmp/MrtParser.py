import json
import multiprocessing
import os
from mrtparse import Reader

from openbmp.mrt2bmp.logger import init_mp_logger

mrt_types = {
    11: 'OSPFv2',
    12: 'TABLE_DUMP',
    13: 'TABLE_DUMP_V2',
    16: 'BGP4MP',
    17: 'BGP4MP_ET',
    32: 'ISIS',
    33: 'ISIS_ET',
    48: 'OSPFv3',
    49: 'OSPFv3_ET'
}

table_dump_v2_subtypes = {
    1: 'PEER_INDEX_TABLE',
    2: 'RIB_IPV4_UNICAST',
    3: 'RIB_IPV4_MULTICAST',
    4: 'RIB_IPV6_UNICAST',
    5: 'RIB_IPV6_MULTICAST',
    6: 'RIB_GENERIC',
}

class MrtFileProcessor:
    def __createBmpCommonHeader(self):
        pass
        """
        BMP Common Header:

          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
         +-+-+-+-+-+-+-+-+
         |    Version    |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                        Message Length                         |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |   Msg. Type   |
         +---------------+
        """

    def __createBmpPeerHeader(self):
        pass
        """
        BMP Peer Header:

          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |   Peer Type   |  Peer Flags   |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |         Peer Distinguisher (present based on peer type)       |
         |                                                               |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                 Peer Address (16 bytes)                       |
         ~                                                               ~
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                           Peer AS                             |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                         Peer BGP ID                           |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                    Timestamp (seconds)                        |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                  Timestamp (microseconds)                     |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        """

class RibProcessor(MrtFileProcessor):

    def __init__(self, file_path, directory_path, router_name, collector_id, forward_queue, log_queue):
        self._file_path = file_path
        self._directory_path = directory_path
        self._router_name = router_name
        self._collector_id = collector_id
        self._forward_queue = forward_queue
        self._log_queue = log_queue

        # Peer index table is array of dictionaries.
        self._peer_index_table = None
        self.__setPeerIndexTable()
        self.__savePeerIndexTable()

    # Main process function to be called.
    def processRibFile(self):
        self._readTableEntries()

    def _readTableEntries(self):
        # Read table dump entries.
        d = Reader(os.path.join(self._directory_path, self._router_name, self._file_path))

        for m in d:
            m = m.mrt

            """
                RIB Entry Header:

                0                   1                   2                   3
                0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
               |                         Sequence Number                       |
               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
               | Prefix Length |
               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
               |                        Prefix (variable)                      |
               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
               |         Entry Count           |  RIB Entries (variable)
               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

            """

            # TABLE_DUMP_V2 - RIB_IPV4_UNICAST OR RIB_IPV6_UNICAST entry
            if 'TABLE_DUMP_V2' == mrt_types[m.type] and ('RIB_IPV4_UNICAST' == table_dump_v2_subtypes[m.subtype] or 'RIB_IPV6_UNICAST' == table_dump_v2_subtypes[m.subtype]):
                # Parse RIB entry header.
                sequence_number = m.rib.seq
                prefix_length = m.rib.plen
                prefix = m.rib.prefix
                entry_count = m.rib.count

                """
                    RIB Entery:

                    0                   1                   2                   3
                    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |         Peer Index            |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |                         Originated Time                       |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |      Attribute Length         |
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                   |                    BGP Attributes... (variable)
                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                """

                for entry in m.rib.entry:
                    peer_index = entry.peer_index
                    originated_time = entry.org_time
                    attribute_length = entry.attr_len

                    for attr in entry.attr:
                        print 'Path Attribute Flags/Type/Length: 0x%02x/%d/%d' % (attr.flag, attr.type, attr.len)


    # Peer Index Table functions.
    def __setPeerIndexTable(self):
        d = Reader(os.path.join(self._directory_path, self._router_name, self._file_path))

        for m in d:
            m = m.mrt

            if m.type == 13 and m.subtype == 1:
                # Create list of dicts.
                peerList = []

                for entry in m.peer.entry:
                    peer = dict()
                    peer['type'] = entry.type

                    # AS number size in bytes (2 bytes or 4 bytes)
                    if entry.type == 0:
                        peer['as_number_size'] = 2
                        peer['ip_address_family'] = 'IPv4'

                    elif entry.type == 1:
                        peer['as_number_size'] = 2
                        peer['ip_address_family'] = 'IPv6'

                    elif entry.type == 2:
                        peer['as_number_size'] = 4
                        peer['ip_address_family'] = 'IPv4'

                    elif entry.type == 3:
                        peer['as_number_size'] = 4
                        peer['ip_address_family'] = 'IPv6'

                    peer['bgp_id'] = entry.bgp_id
                    peer['ip_address'] = entry.ip
                    peer['asn'] = entry.asn

                    peerList.append(peer)

                    self.__sendPeerUpMessage(peer)

                self._peer_index_table = peerList
                break

    def __sendPeerUpMessage(self, peer):
        bmp_peer_up_message = peer

        #TODO: Construct peer up message for the peer.

        self._forward_queue.put(bmp_peer_up_message)

    def __savePeerIndexTable(self):

        # Save peer index table as json
        path = os.path.join(self._directory_path, self._router_name, self._file_path)
        path = os.path.splitext(path)[0] + '.json'

        if not os.path.isfile(path):
            with open(path, 'w') as fp:
                json.dump(self._peer_index_table, fp, sort_keys = True, indent = 4)


class UpdateProcessor:

    def __init__(self, file_path, directory_path, router_name, collector_id, forward_queue, log_queue):
        self._file_path = file_path
        self._directory_path = directory_path
        self._router_name = router_name
        self._collector_id = collector_id
        self._forward_queue = forward_queue
        self._log_queue = log_queue

    def processUpdateFile(self):
        pass


class RouterProcessor:

    def __init__(self, router_name, directory_path, forward_queue, log_queue):

        self._router_name = router_name
        self._directory_path = directory_path
        self._fwd_queue = forward_queue
        self._log_queue = log_queue
        self._collector_id = None
        self._listOfRibAndUpdateFiles = []

        self.__collectListOfRibandUpdateFiles()
        self.__getCollectorID()

    def __collectListOfRibandUpdateFiles(self):

        for d in os.listdir(os.path.join(self._directory_path, self._router_name)):
            if not d.startswith('.'):
                listOfRibs = os.listdir(os.path.join(self._directory_path, self._router_name, d, "RIBS"))
                listOfRibs = [os.path.join(d,"RIBS",e) for e in listOfRibs]
                listOfUpdates = os.listdir(os.path.join(self._directory_path, self._router_name, d, "UPDATES"))
                listOfUpdates = [os.path.join(d,"UPDATES",e) for e in listOfUpdates]
                self._listOfRibAndUpdateFiles = self._listOfRibAndUpdateFiles + listOfRibs + listOfUpdates

        self._listOfRibAndUpdateFiles.sort()

        #TODO: Fix sort function in order to sort correctly.

    def __getCollectorID(self):

        if len(self._listOfRibAndUpdateFiles) > 0:
            firstRIB = (self._listOfRibAndUpdateFiles)[0]
            d = Reader(os.path.join(self._directory_path, self._router_name, firstRIB))
            for m in d:
                m = m.mrt

                if m.type == 13 and m.subtype == 1:
                    self._collector_id = m.peer.collector
                    #print self._collector_id
                    break

    def __sendInitMessage(self):
        #TODO: Send INIT message for the router.
        pass

    def processRouteView(self):
        if len(self._listOfRibAndUpdateFiles) > 0:
            for f in self._listOfRibAndUpdateFiles:
                if "rib" in f:
                    rp = RibProcessor(f, self._directory_path, self._router_name, self._collector_id, self._fwd_queue, self._log_queue)
                    rp.processRibFile()

                elif "updates" in f:
                    up = UpdateProcessor(f, self._directory_path, self._router_name, self._collector_id, self._fwd_queue, self._log_queue)
                    up.processUpdateFile()

class RouteViewsProcessor(multiprocessing.Process):

    def __init__(self, cfg, forward_queue, log_queue):

        multiprocessing.Process.__init__(self)
        self._stop = multiprocessing.Event()

        self._cfg = cfg
        self._fwd_queue = forward_queue
        self._log_queue = log_queue
        self._dir_path = cfg['save_directory_path']
        self.LOG = None

    def run(self):
        self.LOG = init_mp_logger("route_views_processor", self._log_queue)

        self.LOG.info("Running route_views_processor")

        # Get list of router list from the directory.
        listOfRouters = os.listdir(self._dir_path)

        try:
            # Iterate all routers.
            for router in listOfRouters:
                if router.startswith('route-views.') and not self.stopped():
                    # Process the router by creating a 'RouterProcessor'
                    rp = RouterProcessor(str(router), self._dir_path, self._fwd_queue, self._log_queue)
                    rp.processRouteView()

        except KeyboardInterrupt:
            pass

        self.LOG.info("route_views_processor stopped")

    def stop(self):
        self._stop.set()

    def stopped(self):
        return self._stop.is_set()