import urllib2
import os
import datetime
import shutil
import json
from threading import Thread, Lock
from multiprocessing import Manager, Process

NAME_OF_DOWNLOAD_TRACK_FILE = "download_track.json"
ROUTER_FILE_MUTEX = dict()

class Downloader_Thread(Thread):

    def __init__(self, download_queue, master_dir):

        Thread.__init__(self)

        self._stopped = False

        self.route_view_dir_path = master_dir
        self.download_queue = download_queue

    def run(self):

        while not self.stopped():
            df = self.download_queue.get()

            path_parts = df[0].split("/")

            path = os.path.join(self.route_view_dir_path, df[1], path_parts[-3], path_parts[-2], path_parts[-1])
            key = os.path.join(path_parts[-3], path_parts[-2], path_parts[-1])

            # Get file size and last modification date.
            req = urllib2.Request(df[0])
            url_handle = urllib2.urlopen(req)
            headers = url_handle.info()

            etag = headers.getheader("ETag")[1:-1]
            last_modified = headers.getheader("Last-Modified")

            """
            print "Path: " + path
            print "Etag: " + etag
            print "Last modified: " + last_modified
            """

            if not self.__checkFileMetadataInDownloadTrack(df[1], key, etag, last_modified):

                # Download the file.
                with open(path,'wb') as output:
                    output.write(url_handle.read())

                # Save downloaded file info in track file.
                self.__addFileMetadataToDownloadTrack(df[1], key, etag, last_modified)

                print "File is downloaded, does not exist..."

            else:
                pass
                print "File is NOT downloaded, already exists..."

            self.download_queue.task_done()

    def __addFileMetadataToDownloadTrack(self, router_name, file_url, etag, file_modification_date):

        global ROUTER_FILE_MUTEX

        ROUTER_FILE_MUTEX[router_name].acquire()

        try:
            file_path = os.path.join(self.route_view_dir_path, router_name, NAME_OF_DOWNLOAD_TRACK_FILE)

            # Read the corresponding json file.
            with open(file_path) as f:
                data = json.load(f)

            data[file_url] = {"e-tag": etag, "file_modification_date": file_modification_date}

            # Write the data object to the corresponding json file.
            with open(file_path, 'w') as f:
                json.dump(data, f, sort_keys=True, indent=4)

        finally:
            ROUTER_FILE_MUTEX[router_name].release()

    def __checkFileMetadataInDownloadTrack(self, router_name, file_url, etag, file_modification_date):

        global ROUTER_FILE_MUTEX

        ROUTER_FILE_MUTEX[router_name].acquire()

        try:
            file_path = os.path.join(self.route_view_dir_path, router_name, NAME_OF_DOWNLOAD_TRACK_FILE)

            # Add file metadata to the corresponding file.
            with open(file_path) as f:
                data = json.load(f)

            if not data.get(file_url) is None:
                if data[file_url]['e-tag'] == etag and data[file_url]['file_modification_date'] == file_modification_date:
                    return True

                else:
                    return False

            else:
                return False

        finally:
            ROUTER_FILE_MUTEX[router_name].release()

    def stop(self):
        self._stopped = True

    def stopped(self):
        return self._stopped


class RouteDataSynchronizer(Process):

    def __init__(self, cfg, log_queue):
        Process.__init__(self)
        self._stopped = False
        self.LOG = None
        self._log_queue = log_queue

        self.manager = Manager()
        self.download_queue = self.manager.Queue(cfg['router_data']['max_download_queue_size'])

        self.web_address = cfg['router_data']['web_source_address']
        self.route_view_dir_path = cfg['router_data']['save_directory_path']

        self.numberOfThreads = cfg['router_data']['number_of_downloading_threads']
        self.list_downloader_threads = []

        self.__createDirIfNotExist(self.route_view_dir_path)

    def run(self):

        try:
            """ Override """
            routers = self.__getListOfRouters()
            self.__createDownloaderThreadPool()

            for r in routers:
                if not self.stopped():

                    self.__createDownloadTrackFile(r[0])

                    url = self.web_address + r[1] + '/'
                    router_name = r[0]

                    response = urllib2.urlopen(url)
                    html = response.read()

                    if html.find('alt="[DIR]"') != -1:
                        # Directory listing html.
                        file_list_html = html.split('alt="[DIR]"></td><td><a href="')
                        del file_list_html[0]

                        l = file_list_html[-1]
                        link = l[:l.find('">')]

                        if link != 'SH_IP_BGP/' and not self.stopped():
                            url_link = url + link
                            self.__findLatestMrtFiles(url_link, router_name)
                            #print url_link

                else:
                    break

            self.download_queue.join()

        except KeyboardInterrupt:
            print "Stopped by user"

    def __findLatestMrtFiles(self, url, router_name):

        try:

            response = urllib2.urlopen(url)
            html = response.read()

            if html.find('alt="[DIR]"') != -1:
                # Directory listing html.
                file_list_html = html.split('alt="[DIR]"></td><td><a href="')
                del file_list_html[0]

                date = None

                l = file_list_html[0]
                link = l[:l.find('">')]
                url_link = url + link

                if link == "RIBS/":
                    date = self.__findLatestRibFile(url_link, router_name)

                l = file_list_html[1]
                link = l[:l.find('">')]
                url_link = url + link

                if link == "UPDATES/":
                    self.__findLatestUpdateFiles(url_link, router_name, date)

        except KeyboardInterrupt:
            pass

    def __findLatestRibFile(self, url, router_name):

        try:

            response = urllib2.urlopen(url)
            html = response.read()

            if html.find('alt="[   ]"') != -1:
                # Last depth directory, it has list of mrt files.
                file_list_html = html.split('alt="[   ]"></td><td><a href="')
                del file_list_html[0]

                l = file_list_html[-1]

                link = l[:l.find('">')]

                # Check if file exists in the router's download track file.
                url_link = url + link
                url_parts = url_link.split("/")

                self.__createDirIfNotExist(os.path.join(self.route_view_dir_path, router_name, url_parts[-3], url_parts[-2]))

                # Search the link in the download track file.
                # If it does not exist, then delete whole router directory and create again.
                global ROUTER_FILE_MUTEX

                ROUTER_FILE_MUTEX[router_name].acquire()

                try:
                    file_path = os.path.join(self.route_view_dir_path, router_name, NAME_OF_DOWNLOAD_TRACK_FILE)

                    # Add file metadata to the corresponding file.
                    with open(file_path) as f:
                        data = json.load(f)

                    path_parts = url_link.split("/")

                    key = os.path.join(path_parts[-3], path_parts[-2], path_parts[-1])

                    if data.get(key) is None:
                        shutil.rmtree(os.path.join(self.route_view_dir_path, router_name))
                        self.__createDownloadTrackFile(router_name)
                        self.__createDirIfNotExist(
                            os.path.join(self.route_view_dir_path, router_name, url_parts[-3], url_parts[-2]))

                    else:
                        pass

                finally:
                    ROUTER_FILE_MUTEX[router_name].release()

                self.download_queue.put((url_link, router_name))

                # Parse date of the file.
                tokens = link.split('.')
                date = tokens[1] + tokens[2]
                date = datetime.datetime(int(date[0:4]), int(date[4:6]), int(date[6:8]), int(date[8:10]), int(date[10:]))

                return date

        except KeyboardInterrupt:
            pass

    def __findLatestUpdateFiles(self, url, router_name, rib_date):

        try:

            response = urllib2.urlopen(url)
            html = response.read()

            if html.find('alt="[   ]"') != -1:
                # Last depth directory, it has list of mrt files.
                file_list_html = html.split('alt="[   ]"></td><td><a href="')
                del file_list_html[0]

                for l in file_list_html:

                    link = l[:l.find('">')]

                    # Check if file exists in the router's download track file.
                    url_link = url + link
                    url_parts = url_link.split("/")

                    # Parse date of the file.
                    tokens = link.split('.')
                    date = tokens[1] + tokens[2]
                    date = datetime.datetime(int(date[0:4]), int(date[4:6]), int(date[6:8]), int(date[8:10]),
                                             int(date[10:]))

                    if date >= rib_date:

                        self.__createDirIfNotExist(os.path.join(self.route_view_dir_path, router_name, url_parts[-3], url_parts[-2]))

                        self.download_queue.put((url_link, router_name))

                        #print url_link

        except KeyboardInterrupt:
            pass

    def __createDirIfNotExist(self, path):
        if not os.path.exists(path):
            os.makedirs(path)

    def __createDownloaderThreadPool(self):
        for i in range(self.numberOfThreads):
            t = Downloader_Thread(self.download_queue, self.route_view_dir_path)
            t.setDaemon(True)
            t.start()

            self.list_downloader_threads.append(t)

    def __getListOfRouters(self):
        response = urllib2.urlopen(self.web_address)
        html = response.read()

        list_start = html.find("<LI>")
        list_end = html.find("</LI>")

        # Get routers html block.
        all_routers_html = html[list_start+4:list_end-6]

        # Get list of router htmls.
        list_of_routers_html = all_routers_html.split("<br>")

        # Delete last element because last link is not a router.
        del list_of_routers_html[len(list_of_routers_html)-1]

        router_list = []

        for r in list_of_routers_html:
            router_link = r[r.find('HREF="') + 6:r.find('">')]

            start_index_name = r.rfind('quagga bgpd') + 18

            end_index_1 = r.find(')', start_index_name)
            end_index_2 = r.find(' ', start_index_name)

            router_name = r[start_index_name:min(end_index_1,end_index_2)].strip()

            # Initiliaze file lock for each router and adds it to dictionary of locks.
            global ROUTER_FILE_MUTEX
            ROUTER_FILE_MUTEX[router_name] = Lock()
            #print router_name

            router_list.append((router_name, router_link))

        return router_list

    def __createDownloadTrackFile(self, router_name):

        if not os.path.isdir(os.path.join(self.route_view_dir_path, router_name)):
            os.makedirs(os.path.join(self.route_view_dir_path, router_name))

        if not os.path.isfile(os.path.join(self.route_view_dir_path, router_name, NAME_OF_DOWNLOAD_TRACK_FILE)):
            empty_dict = dict()

            with open(os.path.join(self.route_view_dir_path, router_name, NAME_OF_DOWNLOAD_TRACK_FILE), 'w') as outfile:
                json.dump(empty_dict, outfile, sort_keys=True, indent=4)

    def stop(self):
        self._stopped = True

        # Stop all the downloader threads.
        for t in self.list_downloader_threads:
            t.stop()

    def stopped(self):
        return self._stopped

