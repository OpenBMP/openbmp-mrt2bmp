# -*- coding: utf-8 -*-
"""OpenBMP mrt2bmp

  Copyright (c) 2013-2015 Cisco Systems, Inc. and others.  All rights reserved.
  This program and the accompanying materials are made available under the
  terms of the Eclipse Public License v1.0 which accompanies this distribution,
  and is available at http://www.eclipse.org/legal/epl-v10.html

  .. moduleauthor:: Tim Evens <tievens@cisco.com>
"""
import socket
import multiprocessing
import time

from time import sleep
from openbmp.mrt2bmp.Logger import init_mp_logger
from openbmp.mrt2bmp.HelperClasses import Q_Message


class BMPWriter(multiprocessing.Process):
    """ BMP Writer

        Pops messages from forwarder queue and transmits them to remote bmp collector.
    """

    def __init__(self, cfg, forward_queue, log_queue):
        """ Constructor

            :param cfg:             Configuration dictionary
            :param forward_queue:   Output for BMP raw message forwarding
            :param log_queue:       Logging queue - sync logging
        """
        multiprocessing.Process.__init__(self)
        self._stop = multiprocessing.Event()

        self._cfg = cfg
        self._fwd_queue = forward_queue
        self._log_queue = log_queue
        self.LOG = None
        self._isConnected = False

        self._sock = None

    def run(self):
        """ Override """
        self.LOG = init_mp_logger("bmp_writer", self._log_queue)

        self.LOG.info("Running bmp_writer")

        self.connect()

        try:
            # wait for the mapping config to be loaded
            while not self.stopped():
                if self._cfg and 'logging' in self._cfg:
                    break

            # Read queue
            while not self.stopped():

                # Do not pop any message unless connected
                if self._isConnected:
                    if not self._fwd_queue.empty():
                        qm = self._fwd_queue.get()

                        if Q_Message.BMP_MESSAGE == qm.getMsgType():
                            sent = False
                            while not sent:
                                sent = self.send(qm.getMessage())

                        elif Q_Message.RECONNECT_MESSAGE == qm.getMsgType():
                            self.disconnect()
                            self.connect()

                        self._fwd_queue.task_done()

                else:
                    self.LOG.info("Not connected, attempting to reconnect")
                    sleep(1)
                    self.connect()

        except KeyboardInterrupt:
            pass

        self.LOG.info("rewrite stopped")

    def connect(self):
        """ Connect to remote collector

        :return: True if connected, False otherwise/error
        """
        try:
            self._sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self._sock.connect((self._cfg['collector']['host'], self._cfg['collector']['port']))
            self._isConnected = True
            self.LOG.info("Connected to remote collector: %s:%d", self._cfg['collector']['host'],
                          self._cfg['collector']['port'])

        except socket.error as msg:
            self.LOG.error("Failed to connect to remote collector: %r", msg)
            self._isConnected = False

        except KeyboardInterrupt:
            pass

    def send(self, msg):
        """ Send BMP message to socket.

            :param msg:     Message to send/write

            :return: True if sent, False if not sent
        """
        sent = False

        try:
            self._sock.sendall(msg)
            sent = True

        except socket.error as msg:
            self.LOG.error("Failed to send message to collector: %r", msg)
            self.disconnect()
            sleep(1)
            self.connect()

        return sent

    def disconnect(self):
        """ Disconnect from remote collector
        """
        if self._sock:
            self._sock.close()
            self._sock = None
            self.LOG.info("Connection is disconnected to remote collector: %s:%d", self._cfg['collector']['host'],
                          self._cfg['collector']['port'])

        self._isConnected = False

    def isConnected(self):
        return self._isConnected

    def stop(self):
        self._stop.set()

    def stopped(self):
        return self._stop.is_set()
