import json
import multiprocessing
import os
import time
import struct
import socket
import datetime
from multiprocessing import Queue, Manager
from struct import *
from openbmp.mrt2bmp.HelperClasses import Q_Message, moveFileToTempDirectory
from openbmp.mrt2bmp.MrtParser import MrtParser
from openbmp.mrt2bmp.CollectorSender import BMPWriter
from openbmp.mrt2bmp.logger import init_mp_logger

MRT_TYPES = {
    11: 'OSPFv2',
    12: 'TABLE_DUMP',
    13: 'TABLE_DUMP_V2',
    16: 'BGP4MP',
    17: 'BGP4MP_ET',
    32: 'ISIS',
    33: 'ISIS_ET',
    48: 'OSPFv3',
    49: 'OSPFv3_ET'
}

TABLE_DUMP_V2_SUBTYPES = {
    1: 'PEER_INDEX_TABLE',
    2: 'RIB_IPV4_UNICAST',
    3: 'RIB_IPV4_MULTICAST',
    4: 'RIB_IPV6_UNICAST',
    5: 'RIB_IPV6_MULTICAST',
    6: 'RIB_GENERIC',
}

class BGP_Helper:

    def createBgpHeader(self, data_length, message_type):

        """
        BGP Message Header Format:

          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |                                                               |
          +                                                               +
          |                                                               |
          +                                                               +
          |                           Marker                              |
          +                                                               +
          |                                                               |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |          Length               |      Type     |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

          1 - OPEN
          2 - UPDATE
          3 - NOTIFICATION
          4 - KEEPALIVE

        """

        # Marker
        marker = '\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF'

        # Length
        length = struct.pack("!H", data_length + 19)

        # Type
        type = struct.pack("!B", message_type)

        return marker + length + type

    def createBgpOpenMessage(self, as_number, hold_time, bgp_iden, remote_asn):

        """
        Open Message Format:

           0                   1                   2                   3
           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
           +-+-+-+-+-+-+-+-+
           |    Version    |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |     My Autonomous System      |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |           Hold Time           |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                         BGP Identifier                        |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           | Opt Parm Len  |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                                                               |
           |             Optional Parameters (variable)                    |
           |                                                               |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

        The current BGP version number is 4.

        """

        # Version
        version = struct.pack("!B", 4)

        # My Autonomous System
        as_number = 23456

        my_autonomous_system = struct.pack("!H", as_number)

        # Hold Time
        hold_time = struct.pack("!H", hold_time)

        # BGP Identifier
        bgp_identifier = socket.inet_pton(socket.AF_INET, bgp_iden)

        # Optional Parameters (Add BGP Capabilities)
        octet_4_as_cap = struct.pack("!B B", 2, 6) + struct.pack("!B B I", 65, 4, remote_asn)

        # Add AFI, SAFI values to caps.
        mp_ipv4_unicast_cap = struct.pack("!B B", 2, 5) + struct.pack("!B B H B", 1, 4, 1, 1)
        mp_ipv6_unicast_cap = struct.pack("!B B", 2, 5) + struct.pack("!B B H B", 1, 4, 2, 1)

        # Optional_parameters = octet_4_as_cap + mp_ipv4_unicast_cap + mp_ipv6_unicast_cap
        optional_parameters = octet_4_as_cap + mp_ipv4_unicast_cap + mp_ipv6_unicast_cap

        # Optional Parameters Length
        optional_parameters_length = struct.pack("!B", len(optional_parameters))

        # Open Message
        open_message = version + my_autonomous_system + hold_time + bgp_identifier + optional_parameters_length + optional_parameters

        # Bgp Header
        bgp_header = self.createBgpHeader(len(open_message), 1)

        return bgp_header + open_message

    def createBgpUpdateMessage(self, withdrawn_routes, path_attributes, nlri):

        """
        Bgp Update Message:

        +-----------------------------------------------------+
      |   Withdrawn Routes Length (2 octets)                |
      +-----------------------------------------------------+
      |   Withdrawn Routes (variable)                       |
      +-----------------------------------------------------+
      |   Total Path Attribute Length (2 octets)            |
      +-----------------------------------------------------+
      |   Path Attributes (variable)                        |
      +-----------------------------------------------------+
      |   Network Layer Reachability Information (variable) |
      +-----------------------------------------------------+

        """

        bgp_update_message = struct.pack("!H", len(withdrawn_routes)) + withdrawn_routes + \
                              struct.pack("!H", len(path_attributes)) + path_attributes + nlri

        return bgp_update_message

class BMP_Helper:

    def createBmpCommonHeader(self, version, data_length, msg_type):

        """
        BMP Common Header:

          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
         +-+-+-+-+-+-+-+-+
         |    Version    |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                        Message Length                         |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |   Msg. Type   |
         +---------------+

        Message Types:
          *  Type = 0: Route Monitoring
          *  Type = 1: Statistics Report
          *  Type = 2: Peer Down Notification
          *  Type = 3: Peer Up Notification
          *  Type = 4: Initiation Message
          *  Type = 5: Termination Message
          *  Type = 6: Route Mirroring Message

        """

        return struct.pack("!B I B", version, data_length, msg_type)


    def createBmpPerPeerHeader(self, p_type, p_dist, peer, ts_s, ts_ms):

        """
        BMP Peer Header:

          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |   Peer Type   |  Peer Flags   |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |         Peer Distinguisher (present based on peer type)       |
         |                                                               |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                 Peer Address (16 bytes)                       |
         ~                                                               ~
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                           Peer AS                             |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                         Peer BGP ID                           |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                    Timestamp (seconds)                        |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                  Timestamp (microseconds)                     |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

          *  Peer Type = 0: Global Instance Peer
          *  Peer Type = 1: RD Instance Peer
          *  Peer Type = 2: Local Instance Peer

          Peer Flags:

         0 1 2 3 4 5 6 7
         +-+-+-+-+-+-+-+-+
         |V|L|A| Reserved|
         +-+-+-+-+-+-+-+-+
        """

        V_FLAG = 0x80
        L_FLAG = 0x40
        A_FLAG = 0x20

        peer_flags = 0x00

        # V bit
        if peer['ip_address_family'] == "IPv4":
            # Zero added to peer_flags
            peer_address = struct.pack('!12x') + socket.inet_pton(socket.AF_INET, peer['ip_address'])

        elif peer['ip_address_family'] == "IPv6":
            peer_flags |= V_FLAG
            peer_address = socket.inet_pton(socket.AF_INET6, peer['ip_address'])

        # L bit
            peer_flags |= L_FLAG

        if peer['as_number_size'] == 2:
            peer_flags |= A_FLAG

        bgp_id = socket.inet_pton(socket.AF_INET, peer['bgp_id'])

        return struct.pack("!B B Q", p_type, peer_flags, p_dist) + peer_address + struct.pack("!I", int(peer['asn'])) \
            + bgp_id + struct.pack("!I I", ts_s, ts_ms)

class RibProcessor(BMP_Helper, BGP_Helper):

    def __init__(self, file_path, directory_path, router_name, collector_id, forward_queue, log_queue):
        self._file_path = file_path
        self._directory_path = directory_path
        self._router_name = router_name
        self._collector_id = collector_id
        self._forward_queue = forward_queue
        self._log_queue = log_queue

        self._peer_up_message_list = []

        # Peer index table is array of dictionaries.
        self._peer_index_table = None
        self.__setPeerIndexTable()
        self.__savePeerIndexTable()

    # Main process function to be called.
    def processRibFile(self):

        # Iterate through update file.
        mp = MrtParser(os.path.join(self._directory_path, self._router_name, self._file_path))

        for m in mp:

            if MRT_TYPES[m['mrt_header']['type']] == 'TABLE_DUMP_V2' and \
                    (TABLE_DUMP_V2_SUBTYPES[m['mrt_header']['subtype']] == 'RIB_IPV4_UNICAST'):

                for e in m['mrt_entry']['rib_entries']:

                    # 1-) Create BGP Update message
                    bgp_update_message = self.createBgpUpdateMessage(b"", b"".join(e['raw_bgp_attributes']), b"")

                    # 2-) Create BGP Common header
                    bgp_common_header = self.createBgpHeader(len(bgp_update_message), 2)

                    # 3-) Create BMP Per Peer header
                    peer = self._peer_index_table[e['peer_index']]
                    bmp_per_peer_header = self.createBmpPerPeerHeader(0, 0, peer, 0, 0)

                    # 4-) Create BMP Common header
                    bmp_common_header = self.createBmpCommonHeader(3, len(bgp_update_message) +
                                                                   len(bgp_common_header) + len(bmp_per_peer_header) + 6, 0)

                    # Send the message to the collector
                    # Put the message in the queue.
                    qm = bmp_common_header + bmp_per_peer_header + bgp_common_header + bgp_update_message

                    self._forward_queue.put(qm)

    # Peer Index Table functions.
    def __setPeerIndexTable(self):

        mp = MrtParser(os.path.join(os.path.join(self._directory_path, self._router_name, self._file_path)))

        for m in mp:

            if m['mrt_header']['type'] == 13 and m['mrt_header']['subtype'] == 1:

                # Create list of dicts.
                peer_list = m['mrt_entry']['peer_list']

                for peer in peer_list:
                    self._peer_up_message_list.append(self.__getPeerUpMessage(peer))

                self._peer_index_table = peer_list
                break

    def getPeerUpMessageList(self):
        return self._peer_up_message_list

    def __getPeerUpMessage(self, peer):

        # peer up message = Common header + per-peer header + peer up notification
        peer_up_notification = self.__createPeerUpNotification(peer)

        per_peer_header = self.createBmpPerPeerHeader(0, 0, peer, 0, 0)

        common_header = self.createBmpCommonHeader(3, len(per_peer_header) + len(peer_up_notification) + 6, 3)

        qm = common_header + per_peer_header + peer_up_notification

        return qm

    def __createPeerUpNotification(self, peer):

        """
          Peer Up Notification:

          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                 Local Address (16 bytes)                      |
         ~                                                               ~
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |         Local Port            |        Remote Port            |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                    Sent OPEN Message                          |
         ~                                                               ~
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                  Received OPEN Message                        |
         ~                                                               ~
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                 Information (variable)                        |
         ~                                                               ~
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

        """

        # Local Address
        local_address = None

        if peer['ip_address_family'] == 'IPv4':
            local_address = struct.pack('!12x') + socket.inet_pton(socket.AF_INET, "0.0.0.0")

        elif peer['ip_address_family'] == 'IPv6':
            local_address = socket.inet_pton(socket.AF_INET6, "0:0:0:0:0:0:0:0")

        # Local Port
        local_port = pack('!H', 0)

        # Remote Port
        remote_port = pack('!H', 0)

        # Sent OPEN Message
        sent_open_message = self.createBgpOpenMessage(0, 0, self._collector_id, peer['asn'])

        # Received OPEN Message
        received_open_message = self.createBgpOpenMessage(peer['asn'], 0, peer['bgp_id'], 0)

        return local_address + local_port + remote_port + sent_open_message + received_open_message


    def __savePeerIndexTable(self):

        # Save peer index table as json
        path = os.path.join(self._directory_path, self._router_name, 'router_pit.json')

        # Init json object to be saved in a file.
        jsonToSave = {}
        jsonToSave['router_name'] = self._router_name
        jsonToSave['collector_id'] = self._collector_id
        jsonToSave['peer_list'] = self._peer_index_table
        jsonToSave['peer_index_table_source'] = self._file_path

        with open(path, 'w') as fp:
            json.dump(jsonToSave, fp, sort_keys=True, indent=4)


class UpdateProcessor(BMP_Helper, BGP_Helper):

    def __init__(self, file_path, directory_path, router_name, collector_id, forward_queue, log_queue):
        self._isProcessable = True
        self._peer_index_table = None
        self._file_path = file_path
        self._directory_path = directory_path
        self._router_name = router_name
        self._collector_id = collector_id
        self._forward_queue = forward_queue
        self._log_queue = log_queue
        self._peer_index_table= None

        # Load peer index table from router_pit.json in router directory.
        self.__loadPeerIndexTable()

    def __searchInPeerIndexTable(self, peer_ip):

        for e in self._peer_index_table['peer_list']:

            if e['ip_address'] == peer_ip:
                return e

    def processUpdateFile(self):

        if self._isProcessable:

            # Iterate through update file.
            mp = MrtParser(os.path.join(self._directory_path, self._router_name, self._file_path))

            for m in mp:
                # Lookup peer in peer index table for peer bgp id
                if m['mrt_header']['type'] == 16 and (m['mrt_header']['type'] == 2 or m['mrt_header']['type'] == 4):
                    peer = self.__searchInPeerIndexTable(m['mrt_entry']['peer_ip'])

                    # Encode BMP ROUTE-MONITOR message using BMP common header + per peer header + BGP message
                    raw_bgp_message = m['mrt_entry']['raw_bgp_message']

                    per_peer_header = self.createBmpPerPeerHeader(0, 0, peer, 0, 0)

                    common_header = self.createBmpCommonHeader(3, len(per_peer_header) + len(raw_bgp_message) + 6, 0)

                    # Put the message in the queue.
                    qm = common_header + per_peer_header + raw_bgp_message

                    self._forward_queue.put(qm)

    def __loadPeerIndexTable(self):

        # If router_pit.json exists, then load peer index table.
        path = os.path.join(self._directory_path, self._router_name, 'router_pit.json')

        if os.path.isfile(path):
            with open(path) as data_file:
                self._peer_index_table = json.load(data_file)

        # Else, does not process the update file because there is no peer index table.
        else:
            self._isProcessable = False
            print "There is no peer index table for the update file: %s,%s" % self._router_name, self._file_path


class RouterProcessor(BMP_Helper):

    def __init__(self, router_name, directory_path, forward_queue, log_queue, cfg, initial_message_list):

        self._cfg = cfg
        self._initial_message_list = initial_message_list
        self._isToProcess = True
        self._router_name = router_name
        self._directory_path = directory_path
        self._processed_directory_path = cfg['processed_directory_path']

        self._fwd_queue = forward_queue

        self._log_queue = log_queue
        self._collector_id = None
        self._listOfRibAndUpdateFiles = []

        self.__collectListOfRibandUpdateFiles()
        self.__readCollectorId()

        self._initial_message_list.put(self.__getInitMessage())

        self.LOG = init_mp_logger("mrt_parser", self._log_queue)

    def __collectListOfRibandUpdateFiles(self):

        for d in os.listdir(os.path.join(self._directory_path, self._router_name)):
            if os.path.isdir(os.path.join(self._directory_path, self._router_name, d)):
                listOfRibs = []
                listOfUpdates = []

                rib_path = os.path.join(self._directory_path, self._router_name, d, "RIBS")
                update_path = os.path.join(self._directory_path, self._router_name, d, "UPDATES")

                if os.path.isdir(rib_path):
                    listOfRibs = os.listdir(rib_path)
                    listOfRibs = [os.path.join(d,"RIBS",e) for e in listOfRibs]

                if os.path.isdir(update_path):
                    listOfUpdates = os.listdir(update_path)
                    listOfUpdates = [os.path.join(d,"UPDATES",e) for e in listOfUpdates]

                self._listOfRibAndUpdateFiles = self._listOfRibAndUpdateFiles + listOfRibs + listOfUpdates

        # Create tuple list from list of ribs and updates.
        sorting_list = []

        for i, f in enumerate(self._listOfRibAndUpdateFiles):
            if ".bz2" in f:
                # Parse date of the file.
                tokens = f.split('.')
                date = tokens[2] + tokens[3]
                date = datetime.datetime(int(date[0:4]), int(date[4:6]), int(date[6:8]), int(date[8:10]), int(date[10:]))
                sorting_list.append((date, f))

        # Sorts files by their timestamp.
        def getDate(fileInfo):
            return fileInfo[0]

        sorting_list.sort(key=getDate)

        # If there is no file to process, then exit and do not run process function.
        if len(sorting_list) == 0:
            self._isToProcess = False
            return

        else:
            prevFileTimestamp = sorting_list[0][0]

            # Checks if there is an abnormality between mrt file timestamps.
            for f in sorting_list:
                currentFileTimestamp = f[0]
                timeDif = currentFileTimestamp - prevFileTimestamp

                if timeDif.total_seconds()/60 <= self._cfg['timestamp_interval_limit']:
                    pass

                else:
                    # There is an abnormality between timestamps of two files.
                    self._isToProcess = self._cfg['ignore_timestamp_interval_abnormality']
                    print "There is an abnormality between timestamps of two files in %s ." % self._router_name

                prevFileTimestamp = currentFileTimestamp

        self._listOfRibAndUpdateFiles = sorting_list


    def __readCollectorId(self):

        if self._isToProcess:

            # If router_pit.json exists, then read collector id from that file.
            path = os.path.join(self._directory_path, self._router_name, 'router_pit.json')

            if os.path.isfile(path):
                with open(path) as data_file:
                    data = json.load(data_file)
                    self._collector_id = data['collector_id']

            else:
                # If not, then read collector_id from the first rib file.
                firstRIB = self._listOfRibAndUpdateFiles[0][1]

                mp = MrtParser(os.path.join(self._directory_path, self._router_name, firstRIB))
                for m in mp:

                    if m['mrt_header']['type'] == 13 and m['mrt_header']['subtype'] == 1:
                        self._collector_id = m['mrt_entry']['collector_id']
                        break

    def __getInitMessage(self):

        # Generate information TLVs about monitored router.
        """
         TLV Structure:

          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |          Information Type     |       Information Length      |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                 Information (variable)                        |
         ~                                                               ~
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

         Type = 0: String
         Type = 1: sysDescr
         Type = 2: sysName

         sysDescr and sysName are must to sent.

        """

        # sysDescr tlv creation
        f1 = '!H H 1s'
        s1 = calcsize(f1)
        sysDescr_data = pack(f1, 1, 1, ' ')

        # sysName tlv creation
        f2 = '!H H ' + str(len(self._router_name)) + 's'
        s2 = calcsize(f2)
        sysName_data = pack(f2, 2, len(self._router_name), self._router_name)

        common_header = self.createBmpCommonHeader(3, s1 + s2 + 6, 4)

        qm = common_header + sysDescr_data + sysName_data

        return qm

    def __getTerminationMessage(self):

        # Generate information TLVs about monitored router.
        """
         TLV Structure:

          0                   1                   2                   3
          0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |          Information Type     |       Information Length      |
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
         |                 Information (variable)                        |
         ~                                                               ~
         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

         Type = 0: String
         Type = 1: reason

        """

        # Creation of Type 1 reason tlv
        information = struct.pack("!H", 0)
        reason_tlv = struct.pack("!H H", 1, len(information)) + information

        common_header = self.createBmpCommonHeader(3, len(reason_tlv) + 6, 5)

        qm = common_header + reason_tlv

        return qm

    def processRouteView(self):

        if self._isToProcess:
            for f in self._listOfRibAndUpdateFiles:

                print "-- %s is started" % f[1]

                if "rib" in f[1]:

                    rp = RibProcessor(f[1], self._directory_path, self._router_name, self._collector_id, self._fwd_queue, self._log_queue)
                    for m in rp.getPeerUpMessageList():
                        self._initial_message_list.put(m)

                    rp.processRibFile()

                    moveFileToTempDirectory(os.path.join(self._directory_path, self._router_name, f[1]),
                                            os.path.join(self._processed_directory_path, self._router_name, "RIBS"))

                elif "updates" in f[1]:

                    up = UpdateProcessor(f[1], self._directory_path, self._router_name, self._collector_id, self._fwd_queue, self._log_queue)
                    up.processUpdateFile()

                    moveFileToTempDirectory(os.path.join(self._directory_path, self._router_name, f[1]),
                                            os.path.join(self._processed_directory_path, self._router_name, "UPDATES"))

                print "-- %s is ended" % f[1]

        else:
            self.LOG.error("Data of %s cannot be processed..." % self._router_name)

class RouteViewsProcessor(multiprocessing.Process):

    def __init__(self, cfg, log_queue, fwd_queue):
        """ Constructor

            :param cfg:             Configuration dictionary
            :param forward_queue:   Output for BMP raw message forwarding
            :param log_queue:       Logging queue - sync logging
        """

        multiprocessing.Process.__init__(self)
        self._stop = multiprocessing.Event()

        self._cfg_router = cfg['router_data']
        self._cfg_collector = cfg['collector']
        self._log_queue = log_queue
        self._router_dir_path = self._cfg_router['router_directory_path']
        self.LOG = None

        manager = Manager()
        self.initial_message_list = manager.Queue()

        # Start the BMP writer process
        self._fwd_queue = fwd_queue
        self._collector_writer = BMPWriter(cfg, self._fwd_queue, log_queue, self.initial_message_list)
        self._collector_writer.start()

    def run(self):
        """ Override """
        self.LOG = init_mp_logger("mrt_processors", self._log_queue)

        self.LOG.info("Running route_views_processor")

        # Parse name of router from router directory name.
        if os.path.isdir(self._router_dir_path):
            self._dir_path, self.router_name = os.path.split(self._router_dir_path)

        else:
            print "%s is not a directory !" % self._router_dir_path
            self.stop()

        try:
            print "- %s is started" % str(self.router_name)

            while not self.stopped():

                # Process the router by creating a 'RouterProcessor'
                rp = RouterProcessor(str(self.router_name), self._dir_path, self._fwd_queue, self._log_queue, self._cfg_router, self.initial_message_list)
                rp.processRouteView()

                time.sleep(30)

        except KeyboardInterrupt:
            print "- %s is ended" % str(self.router_name)
            self.LOG.info("route_views_processor stopped")
            pass

    def stop(self):
        self._collector_writer.stop()
        self._stop.set()

    def stopped(self):
        return self._stop.is_set()