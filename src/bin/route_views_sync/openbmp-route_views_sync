#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""OpenBMP Route Views Synchronizer

  Copyright (c) 2013-2015 Cisco Systems, Inc. and others.  All rights reserved.
  This program and the accompanying materials are made available under the
  terms of the Eclipse Public License v1.0 which accompanies this distribution,
  and is available at http://www.eclipse.org/legal/epl-v10.html
"""

import getopt
import yaml
import logging
import sys
import time
import signal
from multiprocessing import Queue, Manager

from openbmp.mrt2bmp.RouteDataSynchronizer import RouteDataSynchronizer
from openbmp.mrt2bmp.Logger import LoggerThread

# Root logger
LOG = None

# Running flag for main process
RUNNING = True

# Default App name
APP_NAME = "openbmp-route_views_sync"

def signal_handler(signum, frame):

    """ Signal handler to shutdown the program

        :param signum:          Signal number
        :param frame:           Stack
    """
    global RUNNING, LOG

    if LOG:
        LOG.info("Caught signal %d, exiting", signum)
    else:
        print "Caught signal %d, exiting" % signum

    RUNNING = False

def load_config(cfg_filename, LOG):

    """ Load and validate the configuration from YAML

        Some defaults are applied if any settings are missing.

        :param cfg_filename:    Configuration filename to load
        :param LOG:             logger

        :return: Configuration dictionary is returned
    """
    cfg = {}

    try:
        cfg = yaml.load(file(cfg_filename, 'r'))

        if 'router_data' not in cfg:
            if LOG:
                LOG.error("Configuration is missing 'router_data' section.")
            else:
                print ("Configuration is missing 'router_data' section.")
            sys.exit(2)

        else:
            if cfg['router_data']['number_of_downloading_threads'] < 0 or \
                            cfg['router_data']['number_of_downloading_threads'] > 1000:
                if LOG:
                    LOG.error("Number of downloading threads must be between 1 and 1000.")
                else:
                    print ("Number of downloading threads must be between 1 and 1000.")
                sys.exit(2)

            if cfg['router_data']['max_download_queue_size'] < 0 or \
                            cfg['router_data']['max_download_queue_size'] > 100000:
                if LOG:
                    LOG.error("Max download queue size must be between 1 and 100000.")
                else:
                    print ("Max download queue size must be between 1 and 100000.")
                sys.exit(2)

    except (IOError, yaml.YAMLError), e:
        print "Failed to load mapping config file '%s': %r" % (cfg_filename, e)
        if hasattr(e, 'problem_mark'):
            mark = e.problem_mark
            print ("error on line: %s, column: %s" % (mark.line+1, mark.column+1))

        sys.exit(2)

    return cfg

def usage(prog):

    """ Usage - Prints the usage for this program.

        :param prog:  Program name
    """
    print ""
    print "Usage: %s [OPTIONS]" % prog
    print ""

    print "OPTIONS:"
    print "  -h, --help".ljust(30) + "Print this help menu"
    print "  -c, --config".ljust(30) + "Config filename (default is %s/etc/openbmp-route_views_sync.yml)" % sys.prefix
    print ""

def parse_cmd_args(argv):
    """ Parse commandline arguments and load the configuration file

        Usage is printed and program is terminated if there is an error.

        :param argv:   ARGV as provided by sys.argv.  Arg 0 is the program name

        :returns: Command line arg configuration dictionary
    """
    cfg = {
            'cfg_filename': "%s/bin/route_views_sync/%s.yml" % (sys.prefix, APP_NAME)
           }

    try:
        (opts, args) = getopt.getopt(argv[1:], "hc:",
                                       ["help", "config="])

        for o, a in opts:
            if o in ("-h", "--help"):
                usage(argv[0])
                sys.exit(0)

            elif o in ("-c", "--config"):
                cfg['cfg_filename'] = a

            else:
                usage(argv[0])
                sys.exit(1)

    except getopt.GetoptError as err:
        print str(err)  # will print something like "option -a not recognized"
        usage(argv[0])
        sys.exit(2)

    return cfg


def main():

    """ Main entry point """
    global LOG, RUNNING

    cmd_cfg = parse_cmd_args(sys.argv)
    cfg = load_config(cmd_cfg['cfg_filename'], LOG)

    # Shared dictionary between processes
    manager = Manager()
    cfg_dict = manager.dict()
    cfg_dict['router_data'] = cfg['router_data']
    cfg_dict['logging'] = cfg['logging']

    # Setup signal handlers
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGQUIT, signal_handler)
    signal.signal(signal.SIGABRT, signal_handler)

    # Setup the multiprocessing logging queue
    log_queue = Queue()
    thread_logger = LoggerThread(log_queue, cfg_dict['logging'])
    thread_logger.start()

    LOG = logging.getLogger()

    # Synchronizes remote mrt files with local directory.
    rds = RouteDataSynchronizer(cfg_dict, log_queue)
    rds.start()

    # Monitor/do something else if needed
    while RUNNING and rds.is_alive():

        try:
            time.sleep(3)

        except KeyboardInterrupt:
            print "\nRoute sync stopped by user"
            RUNNING = False
            rds.stop()
            rds.join()
            break

    print "Route sync finished"

    manager.shutdown()

    thread_logger.stop()
    thread_logger.join()

    sys.exit(0)

if __name__ == '__main__':
    main()